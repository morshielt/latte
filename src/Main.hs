-- -- automatically generated by BNF Converter
-- module Main where


-- import           System.IO                      ( stdin
--                                                 , hGetContents
--                                                 )
-- import           System.Environment             ( getArgs
--                                                 , getProgName
--                                                 )
-- import           System.Exit                    ( exitFailure
--                                                 , exitSuccess
--                                                 )
-- import           Control.Monad                  ( when )

-- import           LexLatte
-- import           ParLatte
-- -- import           SkelLatte
-- import           PrintLatte
-- import           AbsLatte




-- import           ErrM

-- type ParseFun a = [Token] -> Err a

-- myLLexer = myLexer

-- type Verbosity = Int

-- putStrV :: Verbosity -> String -> IO ()
-- putStrV v s = when (v > 1) $ putStrLn s

-- runFile :: (Print a, Show a) => Verbosity -> ParseFun a -> FilePath -> IO ()
-- runFile v p f = putStrLn f >> readFile f >>= run v p

-- run :: (Print a, Show a) => Verbosity -> ParseFun a -> String -> IO ()
-- run v p s =
--     let ts = myLLexer s
--     in  case p ts of
--             Bad s -> do
--                 putStrLn "\nParse              Failed...\n"
--                 putStrV v "Tokens:"
--                 putStrV v $ show ts
--                 putStrLn s
--                 exitFailure
--             Ok tree -> do
--                 putStrLn "\nParse Successful!"
--                 showTree v tree

--                 exitSuccess


-- showTree :: (Show a, Print a) => Int -> a -> IO ()
-- showTree v tree = do
--     putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
--     putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

-- usage :: IO ()
-- usage = do
--     putStrLn $ unlines
--         [ "usage: Call with one of the following argument combinations:"
--         , "  --help          Display this help message."
--         , "  (no arguments)  Parse stdin verbosely."
--         , "  (files)         Parse content of files verbosely."
--         , "  -s (files)      Silent mode. Parse content of files silently."
--         ]
--     exitFailure

-- main :: IO ()
-- main = do
--     args <- getArgs
--     case args of
--         ["--help"] -> usage
--         []         -> getContents >>= run 2 pProgram
--         "-s" : fs  -> mapM_ (runFile 0 pProgram) fs
--         fs         -> mapM_ (runFile 2 pProgram) fs






import           System.Environment             ( getArgs )
import           System.Exit                    ( exitFailure )
import           System.IO                      ( stderr
                                                , hPutStrLn
                                                )
import           Control.Monad.Except

import           ParLatte
import           AbsLatte

import           StaticAnalysis                 ( runStaticAnalysis )
-- import           Interpreter

import           ErrM

import           Control.Monad                  ( when )
import           PrintLatte

check :: String -> IO ()
check s = case pProgram (myLexer s) of
    Bad err -> do
        hPutStrLn stderr $ "[Syntax error] " ++ err
        exitFailure
    Ok tree -> do
        putStrLn "\nParse Successful!"
        showTree tree
        tcRes <- runExceptT $ runStaticAnalysis tree
        case tcRes of
            Left e -> do
                hPutStrLn stderr $ "[Typecheck exception] " ++ e
                exitFailure
            Right _ -> return ()
            -- Right _ -> do
            --     res <- runExceptT $ runInterpreter tree
            --     case res of
            --         Left e -> do
            --             hPutStrLn stderr $ "[Runtime exception] " ++ e
            --             exitFailure
            --         Right _ -> return ()

showTree :: (Show a, Print a) => a -> IO ()
showTree tree = do
    putStrLn $ "\n[Abstract Syntax]\n\n" ++ show tree
    putStrLn $ "\n[Linearized tree]\n\n" ++ printTree tree

main :: IO ()
main = do
    args <- getArgs
    case args of
        [file] -> readFile file >>= check
        []     -> getContents >>= check
        _      -> do
            putStrLn "Usage: ??? <SourceFile>"
            exitFailure
